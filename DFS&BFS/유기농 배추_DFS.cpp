#include <iostream>
#include <cstring>

using namespace std;

int n, m, cabbage;    // n: 배추밭의 세로길이, m: 배추밭의 가로길이, cabbage: 심어져 있는 배추의 위치 개수
bool arr[51][51];     // 1: 배추가 있는 곳, 0: 배추가 없는 곳 확인하기 위함
bool visited[51][51]; // 방문 여부
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

bool dfs(int y, int x)
{
    if (visited[y][x])
        return false;
    visited[y][x] = true;

    for (int i = 0; i < 4; i++)
    {
        int next_x = x + dx[i]; // 3. 동, 서, 남, 북으로 1칸씩 이동
        int next_y = y + dy[i];

        if (next_x >= 0 && next_y >= 0 && next_x < m && next_y < n && arr[next_y][next_x]) // 4. 인근 지역에 배추 있을 경우, 해당 지역 방문 처리
            dfs(next_y, next_x);
    }
    return true;
}

int main(void)
{
    int TC; // 테스트 케이스
    cin >> TC;
    for (int i = 0; i < TC; i++)
    {
        cin >> m >> n >> cabbage;
        memset(arr, 0, sizeof(arr));
        memset(visited, 0, sizeof(visited));

        for (int j = 0; j < cabbage; j++)
        {
            int x = 0, y = 0;
            cin >> x >> y;
            arr[y][x] = 1; // 1. 행 - y축, 열 - x축
        }

        int bug_count = 0;

        for (int j = 0; j < n; j++)
        {
            for (int k = 0; k < m; k++)
            {
                if (arr[j][k] && !visited[j][k])
                { // 2. 탐색 안한 구역일 경우, dfs 수행 & count 추가
                    if (dfs(j, k))
                        bug_count++;
                }
            }
        }
        cout << bug_count << '\n';
    }
}

// <주의>
// 1. 행은 y축, 열은 x 축이라는 점

// 2. 배추들의 위치들이 구역별로 나뉘어있다는 점

// 3. 격자 위에서 동, 서, 남, 북으로 1칸 이내에 인근 배추가 있을 수 있다는 점

// <풀이>
// 이때, 배추 흰 지렁이가 한 구역을 다 커버할 수 있으므로, 결국 격자 위에 배추 구역이 몇 개나 있는지를 구하면 되는 문제이다.
// 이때 dfs를 이용해 탐색하고자 하는 배추가 이미 탐색한 구역의 배추인지를 확인하면 된다.

// 따라서 위 내용을 기반으로 다음과 같이 코드를 구현해주면 된다.

// 1. 배추 위치 기록
// 행을 y축, 열을 x축으로 하여 배열에 배추의 위치를 표기해준다. 즉 다음과 같이 표기해줄 수 있다.
// a[y][x] = 1;

// 2. 배추 전수 조사
// 전체 행렬 칸을 전수 조사하여 배추가 있는지 확인하고, 만약 배추가 있을 경우 아직 조사하지 않은 구역이라면 dfs를 통해 주변에 다른 배추가 있는지 조사해준다.

// 3. 주변으로 이동
// 주변에 다른 배추가 있는지 조사하기 위해 동, 서, 남, 북으로 움직인다.
// 이때 동, 서, 남, 북은 2차원 배열의 관점에서 다음과 같이 표현할 수 있다.

// 동 : (0, 1)

// 서 : (0, -1)

// 남 : (1, 0)

// 북 : (-1, 0)

// 따라서 for문을 이용해 동, 서, 남, 북으로 (총 4차례) 이동한 좌표를 계산해준다.

// 4. 이동한 위치의 배추 및 그 주변을 조사
// 만약 이동한 위치에 배추가 있다면 조사 완료 (방문) 표시를 해주고, dfs를 통해 그 주변을 다시 조사해준다.
// 더 이상 주변에 배추가 없을 때까지 계속 이를 반복해준다.

// 아직 방문하지 않은 배추를 발견할 때마다 애벌레의 수가 1씩 증가된다.
// 만약 같은 구역 내에서 이미 방문한 배추를 한번 더 방문하게 되더라도, 이전의 배추가 주변을 조사하면서 방문 처리를 했기 때문에
// dfs 함수에서 false를 반환해 애벌레의 수가 증가하지 않는다.